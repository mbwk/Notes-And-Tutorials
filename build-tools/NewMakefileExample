# example manually written makefile, for a project sorted into directories
# by Karl Birch
#
# having everything crammed into the root directory is very disorganised
# it may be better to seperate the files by type like so:
# project/ = executable, makefile, git files
# project/src/ = .cpp source files
# project/include/ = .hpp header files
# project/build/ = .o object files
#
# TIP: to have empty directories in a git repository (e.g. for the above build directory),
#      place a gitignore that blacklists everything but itself into that directory.
#      # project/build/.gitignore
#      *
#      !.gitignore
#
# what this example does NOT cover:
# statically linking
# cross compilation
# automated tarballs
#
# this example has only been tested with GNU make. BSD make might work too.
# for projects that need to build on other platforms, please consider CMake
# or GNU autotools.
#
# also, slight update to compilation options

CC				= gcc # GCC C compiler
CXX				= g++ # GCC C++ compiler
CPPFLAGS			= -fdiagnostics-color=always -std=c++11 -Wall -Werror -g -iquote include/ # C++ compilation flags, -iquote is for your #include statements
				# -fdiagnostics-color is an sweet new flag added in GCC 4.9, that gives clang-like pretty debug messages, remove if on older version
				# -std=c++11 is based. please use at least c++11 whenever possible.
LD				= $(CXX) # your linker, GCC does this
LDFLAGS				= -lboost_system -lboost_program_options # link to system libraries, in this case, for the boost/program_options.hpp header
STRIP				= strip --strip-unneeded # the -g in the flags above adds debug symbols to your binary. this removes them to considerably reduce size.
RM				= rm # remove, trash, delete, etc

# here you specify filenames, and how the files are organised into seperate directories
FILES				= main class1 class2 util model # all your source files. one nice idea would be a command/script to get the filenames from the src/ directory.
SRCDIR				= src # where your source files are kept
OBJDIR				= build # where your .o object files are kept

# these next statements automatically compute source/object filenames based on the specifications you provided above
SRCEXT				= ${addsuffix .cpp,$(FILES)}
OBJEXT				= ${addsuffix .o,$(FILES)}
SRC				= ${addprefix $(SRCDIR)/,$(SRCEXT)}
OBJ				= ${addprefix $(OBJDIR)/,$(OBJEXT)}

# what you want your final executable to be called
EXE				= miyabotplus


build/%.o: src/%.cpp
				$(CXX) $(CPPFLAGS) -c $< -o $@

all: $(EXE)

$(EXE): $(OBJ)
				$(LD) $(CPPFLAGS) -o $@ $(OBJ) $(LDFLAGS)

clean:
				$(RM) -f $(EXE) $(OBJ)

# strips debugging symbols for your executable, so it is ready to send to other people
dist: $(EXE)
				$(STRIP) $(EXE)

